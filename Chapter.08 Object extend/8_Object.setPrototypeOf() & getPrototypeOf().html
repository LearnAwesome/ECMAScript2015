<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
		//设置与获取原型
			//Object.getPrototypeOf() 读取对象原型
//			function Foo() {}
//			Foo.prototype.abc = function() {}
//			let f = new Foo();
//			console.log( f.__proto__ ); //{abc: ƒ, constructor: ƒ}  __proto__就是对象的原型(因为这是一个内部属性，并不是带外公开的API，不推荐使用)
//			console.log( Object.getPrototypeOf( f ) ); //{abc: ƒ, constructor: ƒ} 也可以获取对象的原型
//			console.log( Object.getPrototypeOf( f ) === f.__proto__ ); //true 上面两种方法等价
			
			//Object.setPrototypeOf() 改写对象原型
			function Foo() {}
//			Foo.prototype.cons = function() {
//				console.log(this);
//			};
//			let f = new Foo();
//			Foo.prototype.bcd = 2;
//			f.__proto__.abc = function() {}; //可以通过__proto__来直接改写原型(不推荐)
//			console.log( Object.getPrototypeOf( f ) ); //{abc: ƒ, constructor: ƒ}
//			let proto = Object.getPrototypeOf( f ); //先获取原型
//			proto.qwer = 1; //修改原型
//			console.log( Object.getPrototypeOf( f ) ); //{qwer: 1, abc: ƒ, constructor: ƒ}
			let newProto = {
//				constructor: this, //这样的constructor就变成可枚举的属性了，而原有的是不可枚举属性
				abc: 123,
				cons() {
					console.log(this);
				}
			};
//			Object.defineProperty( newProto, 'constructor', {
//				value: this,
//				enumerable: false
//			} );
//			console.log( f.constructor == Foo )
//			Object.setPrototypeOf( f, newProto );  //或者直接设置一个新的原型
			Foo.prototype = newProto;
			let f = new Foo();
//			console.log( f instanceof Foo )
//			console.log( Object.getPrototypeOf( f ) ); //{abc: 123}
			f.cons();
//			console.log(  )
		
		</script>
	</body>
</html>
